Let's create a single page layout.

```tsx file="app/layout.tsx"
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'Chess App',
  description: 'Chess app made in React and next.js',
  generator: '',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

Then, we create a single page app component.

```tsx file="app/page.tsx"
import ChessGame from "@/components/chess-game"

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-4 bg-gray-100">
      <h1 className="text-3xl font-bold mb-6">Chess</h1>
      <ChessGame />
    </main>
  )
}
```

We must also generate the UI theme for all components.

```tsx file="components/theme-provider.tsx"
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
```

Then, we define the rules and state management for the game.

```tsx file="components/chess-game.tsx"
"use client"

import { useState, useEffect } from "react"
import ChessBoard from "./chess-board"
import GameInfo from "./game-info"
import { initialBoardState, PieceType, Color, type Position, type ChessPiece } from "@/lib/chess-types"
import { isValidMove, getValidMoves, makeMove, isCheck, isCheckmate } from "@/lib/chess-logic"

export default function ChessGame() {
  const [board, setBoard] = useState<(ChessPiece | null)[][]>(initialBoardState)
  const [currentPlayer, setCurrentPlayer] = useState<Color>(Color.White)
  const [selectedPiece, setSelectedPiece] = useState<Position | null>(null)
  const [validMoves, setValidMoves] = useState<Position[]>([])
  const [capturedPieces, setCapturedPieces] = useState<{
    [Color.White]: PieceType[]
    [Color.Black]: PieceType[]
  }>({
    [Color.White]: [],
    [Color.Black]: [],
  })
  const [gameStatus, setGameStatus] = useState<string>("White's Turn") // Initialize with White's Turn
  const [moveHistory, setMoveHistory] = useState<string[]>([])
  const [lastMove, setLastMove] = useState<{ from: Position; to: Position; piece: ChessPiece } | null>(null)

  // Update valid moves when a piece is selected
  useEffect(() => {
    if (selectedPiece) {
      const moves = getValidMoves(board, selectedPiece, currentPlayer, lastMove)
      setValidMoves(moves)
    } else {
      setValidMoves([])
    }
  }, [selectedPiece, board, currentPlayer, lastMove])

  // Check for check/checkmate after each move
  useEffect(() => {
    if (isCheck(board, currentPlayer)) {
      if (isCheckmate(board, currentPlayer)) {
        setGameStatus(`Checkmate! ${currentPlayer === Color.White ? "Black" : "White"} wins!`)
      } else {
        setGameStatus(`${currentPlayer === Color.White ? "White" : "Black"} is in check!`)
      }
    } else {
      setGameStatus(`${currentPlayer === Color.White ? "White's" : "Black's"} Turn`)
    }
  }, [board, currentPlayer])

  const handleSquareClick = (position: Position) => {
    // If no piece is selected and the clicked square has a piece of the current player's color
    if (!selectedPiece && board[position.row][position.col]?.color === currentPlayer) {
      setSelectedPiece(position)
      return
    }

    // If a piece is already selected
    if (selectedPiece) {
      // If clicking on the same piece, deselect it
      if (selectedPiece.row === position.row && selectedPiece.col === position.col) {
        setSelectedPiece(null)
        return
      }

      // If clicking on another piece of the same color, select that piece instead
      if (board[position.row][position.col]?.color === currentPlayer) {
        setSelectedPiece(position)
        return
      }

      // Check if the move is valid
      if (isValidMove(board, selectedPiece, position, currentPlayer, lastMove)) {
        const capturedPiece = board[position.row][position.col]

        // Update captured pieces
        if (capturedPiece) {
          setCapturedPieces((prev) => {
            const oppositeColor = currentPlayer === Color.White ? Color.Black : Color.White
            return {
              ...prev,
              [oppositeColor]: [...prev[oppositeColor], capturedPiece.type],
            }
          })
        }

        // Make the move
        const newBoard = makeMove(board, selectedPiece, position, lastMove)
        setBoard(newBoard)

        setLastMove({
          from: selectedPiece,
          to: position,
          piece: board[selectedPiece.row][selectedPiece.col]!,
        })

        // Add to move history with proper chess notation
        const piece = board[selectedPiece.row][selectedPiece.col]
        let moveNotation = ""

        // Handle castling
        if (piece?.type === PieceType.King && Math.abs(position.col - selectedPiece.col) === 2) {
          moveNotation = position.col > selectedPiece.col ? "O-O" : "O-O-O"
        } else {
          const pieceNotation = getPieceNotation(piece?.type)
          const fromCol = String.fromCharCode(97 + selectedPiece.col) // Convert 0-7 to a-h
          const fromRow = 8 - selectedPiece.row // Convert 0-7 to 8-1
          const toCol = String.fromCharCode(97 + position.col) // Convert 0-7 to a-h
          const toRow = 8 - position.row // Convert 0-7 to 8-1

          // Check if it's a capture
          const isCapture =
            board[position.row][position.col] !== null ||
            (piece?.type === PieceType.Pawn && selectedPiece.col !== position.col) // En passant

          // For pawns, include the file only on captures
          if (piece?.type === PieceType.Pawn) {
            moveNotation = isCapture ? `${fromCol}x${toCol}${toRow}` : `${toCol}${toRow}`

            // Check for pawn promotion (pawns automatically promote to queen in our implementation)
            const isPromotion =
              (piece.color === Color.White && position.row === 0) || (piece.color === Color.Black && position.row === 7)
            if (isPromotion) {
              moveNotation += "=Q"
            }
          } else {
            // For other pieces, include the piece symbol and capture notation if needed
            moveNotation = `${pieceNotation}${isCapture ? "x" : ""}${toCol}${toRow}`
          }
        }

        // Make the move to check if it results in check or checkmate
        const newBoardAfterMove = makeMove(board, selectedPiece, position, lastMove)
        const nextPlayer = currentPlayer === Color.White ? Color.Black : Color.White

        // Add check or checkmate notation
        if (isCheckmate(newBoardAfterMove, nextPlayer)) {
          moveNotation += "#"
        } else if (isCheck(newBoardAfterMove, nextPlayer)) {
          moveNotation += "+"
        }

        setMoveHistory((prev) => [...prev, moveNotation])

        // Switch player
        setCurrentPlayer(currentPlayer === Color.White ? Color.Black : Color.White)
        setSelectedPiece(null)
      }
    }
  }

  const getPieceNotation = (pieceType?: PieceType): string => {
    if (!pieceType) return ""
    switch (pieceType) {
      case PieceType.King:
        return "K"
      case PieceType.Queen:
        return "Q"
      case PieceType.Rook:
        return "R"
      case PieceType.Bishop:
        return "B"
      case PieceType.Knight:
        return "N"
      case PieceType.Pawn:
        return ""
    }
  }

  const resetGame = () => {
    setBoard(initialBoardState)
    setCurrentPlayer(Color.White)
    setSelectedPiece(null)
    setValidMoves([])
    setCapturedPieces({
      [Color.White]: [],
      [Color.Black]: [],
    })
    setGameStatus("White's Turn") // Set to White's Turn directly
    setMoveHistory([])
    setLastMove(null)
  }

  return (
    <div className="flex flex-col md:flex-row gap-4 items-stretch md:items-stretch">
      <ChessBoard
        board={board}
        selectedPiece={selectedPiece}
        validMoves={validMoves}
        onSquareClick={handleSquareClick}
      />
      <GameInfo
        currentPlayer={currentPlayer}
        capturedPieces={capturedPieces}
        gameStatus={gameStatus}
        moveHistory={moveHistory}
        onResetGame={resetGame}
      />
    </div>
  )
}
```

We also create the 8x8 board with highlightable squares.

```tsx file="components/chess-board.tsx"
"use client"

import type { ChessPiece, Position } from "@/lib/chess-types"
import ChessPieceComponent from "./chess-piece"

interface ChessBoardProps {
  board: (ChessPiece | null)[][]
  selectedPiece: Position | null
  validMoves: Position[]
  onSquareClick: (position: Position) => void
}

export default function ChessBoard({ board, selectedPiece, validMoves, onSquareClick }: ChessBoardProps) {
  const isValidMove = (row: number, col: number) => {
    return validMoves.some((move) => move.row === row && move.col === col)
  }

  const isSelected = (row: number, col: number) => {
    return selectedPiece?.row === row && selectedPiece?.col === col
  }

  return (
    <div className="grid grid-cols-8 border-2 border-gray-800 shadow-lg w-full max-w-[35rem] md:max-w-[40rem] lg:max-w-[45rem]">
      {board.map((row, rowIndex) =>
        row.map((piece, colIndex) => {
          const isLight = (rowIndex + colIndex) % 2 === 0
          const squareColor = isLight ? "bg-amber-100" : "bg-amber-800"
          const isHighlighted = isSelected(rowIndex, colIndex)
          const isValidMoveSquare = isValidMove(rowIndex, colIndex)

          return (
            <div
              key={`${rowIndex}-${colIndex}`}
              className={`
                aspect-square flex items-center justify-center relative
                ${squareColor}
                ${isHighlighted ? "ring-4 ring-blue-500 ring-inset" : ""}
                ${isValidMoveSquare ? "cursor-pointer" : ""}
              `}
              onClick={() => onSquareClick({ row: rowIndex, col: colIndex })}
            >
              {/* Valid move indicator */}
              {isValidMoveSquare && (
                <div className={`absolute inset-0 flex items-center justify-center ${piece ? "bg-red-500/30" : ""}`}>
                  {!piece && <div className="w-3 h-3 rounded-full bg-gray-500/50"></div>}
                </div>
              )}

              {/* Chess piece */}
              {piece && <ChessPieceComponent piece={piece} />}
            </div>
          )
        }),
      )}
    </div>
  )
}
```

We then create the component for all the controls and move history.

```tsx file="components/game-info.tsx"
"use client"

import React, { useRef, useEffect, useState } from "react"
import { Button } from "@/components/ui/button"
import { Color, PieceType } from "@/lib/chess-types"
import { RotateCcw, Clipboard, Download, Check } from "lucide-react"

interface GameInfoProps {
  currentPlayer: Color
  capturedPieces: {
    [Color.White]: PieceType[]
    [Color.Black]: PieceType[]
  }
  gameStatus: string
  moveHistory: string[]
  onResetGame: () => void
}

export default function GameInfo({
  currentPlayer,
  capturedPieces,
  gameStatus,
  moveHistory,
  onResetGame,
}: GameInfoProps) {
  const moveHistoryRef = useRef<HTMLDivElement>(null)
  const [copied, setCopied] = useState(false)

  // Auto-scroll to the bottom of move history when new moves are added
  useEffect(() => {
    if (moveHistoryRef.current) {
      moveHistoryRef.current.scrollTop = moveHistoryRef.current.scrollHeight
    }
  }, [moveHistory])

  // Reset copied state after 2 seconds
  useEffect(() => {
    if (copied) {
      const timer = setTimeout(() => setCopied(false), 2000)
      return () => clearTimeout(timer)
    }
  }, [copied])

  const renderCapturedPieces = (color: Color) => {
    return capturedPieces[color].map((pieceType, index) => {
      const symbol = getPieceSymbol(pieceType, color)
      return (
        <span key={index} className="text-sm">
          {symbol}
        </span>
      )
    })
  }

  const getPieceSymbol = (type: PieceType, color: Color) => {
    switch (type) {
      case PieceType.King:
        return color === Color.White ? "♔" : "♚"
      case PieceType.Queen:
        return color === Color.White ? "♕" : "♛"
      case PieceType.Rook:
        return color === Color.White ? "♖" : "♜"
      case PieceType.Bishop:
        return color === Color.White ? "♗" : "♝"
      case PieceType.Knight:
        return color === Color.White ? "♘" : "♞"
      case PieceType.Pawn:
        return color === Color.White ? "♙" : "♟"
      default:
        return ""
    }
  }

  const formatMoveHistoryForExport = () => {
    let formattedText = "Chess Game Move History\n\n"

    for (let i = 0; i < Math.ceil(moveHistory.length / 2); i++) {
      formattedText += `${i + 1}. ${moveHistory[i * 2] || ""} ${moveHistory[i * 2 + 1] || ""}\n`
    }

    return formattedText
  }

  const copyMoveHistory = () => {
    const text = formatMoveHistoryForExport()
    navigator.clipboard.writeText(text).then(() => {
      setCopied(true)
    })
  }

  const downloadMoveHistory = () => {
    const text = formatMoveHistoryForExport()
    const blob = new Blob([text], { type: "text/plain" })
    const url = URL.createObjectURL(blob)

    const a = document.createElement("a")
    a.href = url
    a.download = "chess_game_history.txt"
    document.body.appendChild(a)
    a.click()

    // Cleanup
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }

  return (
    <div className="bg-white p-3 rounded-lg shadow-md w-full sm:max-w-100 md:max-w-[12.0rem] lg:max-w-[12.0rem] flex flex-col h-full">
      {/* Header with title and reset button */}
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-lg font-bold leading-none">Game Info</h2>
        <Button variant="outline" size="sm" className="h-7 px-2" onClick={onResetGame}>
          <RotateCcw className="mr-1 h-3.5 w-3.5" />
          <span className="text-xs">Reset</span>
        </Button>
      </div>

      {/* Current player status */}
      <div className="mb-4 bg-gray-50 p-2 rounded border">
        <div className="flex items-center gap-2">
          <div
            className={`w-3.5 h-3.5 rounded-full ${
              currentPlayer === Color.White ? "bg-white border border-black" : "bg-black"
            }`}
          ></div>
          <p className="font-medium text-sm leading-tight">{gameStatus}</p>
        </div>
      </div>

      {/* Captured pieces section */}
      <div className="mb-4">
        <h3 className="font-medium text-sm mb-1.5 text-gray-700 border-b pb-1">Captured Pieces</h3>
        <div className="flex flex-col gap-1.5">
          <div className="flex items-center flex-wrap">
            <span className="font-medium text-xs mr-1.5 text-gray-600 w-10">White:</span>
            <div className="flex gap-0.5 flex-wrap">
              {capturedPieces[Color.White].length > 0 ? (
                renderCapturedPieces(Color.White)
              ) : (
                <span className="text-xs text-gray-400 italic">None</span>
              )}
            </div>
          </div>
          <div className="flex items-center flex-wrap">
            <span className="font-medium text-xs mr-1.5 text-gray-600 w-10">Black:</span>
            <div className="flex gap-0.5 flex-wrap">
              {capturedPieces[Color.Black].length > 0 ? (
                renderCapturedPieces(Color.Black)
              ) : (
                <span className="text-xs text-gray-400 italic">None</span>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Move history section */}
      <div className="mt-auto">
        <div className="flex items-center justify-between mb-1.5">
          <h3 className="font-medium text-sm text-gray-700">Move History</h3>
          <div className="flex gap-1">
            <Button variant="ghost" size="icon" className="h-6 w-6" onClick={copyMoveHistory} title="Copy move history">
              {copied ? <Check className="h-3.5 w-3.5" /> : <Clipboard className="h-3.5 w-3.5" />}
            </Button>
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6"
              onClick={downloadMoveHistory}
              title="Download move history"
            >
              <Download className="h-3.5 w-3.5" />
            </Button>
          </div>
        </div>
        <div ref={moveHistoryRef} className="h-[40px] overflow-y-auto border rounded px-2 bg-gray-50 scroll-smooth">
          {moveHistory.length > 0 ? (
            <div className="grid grid-cols-[auto_1fr_1fr] gap-x-2 text-sm">
              {Array.from({ length: Math.ceil(moveHistory.length / 2) }).map((_, i) => (
                <React.Fragment key={i}>
                  <div className="font-medium text-gray-500">{i + 1}.</div>
                  <div>{moveHistory[i * 2]}</div>
                  <div>{moveHistory[i * 2 + 1] || ""}</div>
                </React.Fragment>
              ))}
            </div>
          ) : (
            <p className="text-gray-500 text-center text-sm">No moves yet</p>
          )}
        </div>
      </div>
    </div>
  )
}
```

Then, we descibe all chess pieces by their corresponding text characters.

```tsx file="components/chess-piece.tsx"
import { type ChessPiece, PieceType, Color } from "@/lib/chess-types"

interface ChessPieceProps {
  piece: ChessPiece
}

export default function ChessPieceComponent({ piece }: ChessPieceProps) {
  const getPieceSymbol = () => {
    const { type, color } = piece

    switch (type) {
      case PieceType.King:
        return color === Color.White ? "♔" : "♚"
      case PieceType.Queen:
        return color === Color.White ? "♕" : "♛"
      case PieceType.Rook:
        return color === Color.White ? "♖" : "♜"
      case PieceType.Bishop:
        return color === Color.White ? "♗" : "♝"
      case PieceType.Knight:
        return color === Color.White ? "♘" : "♞"
      case PieceType.Pawn:
        return color === Color.White ? "♙" : "♟"
      default:
        return ""
    }
  }

  return <div className="text-4xl select-none">{getPieceSymbol()}</div>
}
```

We define a toast alert.

```tsx file="hooks/use-toast.ts"
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```

We also create utilities for detecting mobile browsers.

```tsx file="hooks/use-mobile.tsx"
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```

Then, we merge Tailwind css into our JS environment.

```tsx file="lib/utils.ts"
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

We also need dedicated utilities to define all the nuance of chess moves.

```tsx file="lib/chess-logic.ts"
import { type ChessPiece, type Position, PieceType, Color } from "./chess-types"

// Deep clone the board
export function cloneBoard(board: (ChessPiece | null)[][]): (ChessPiece | null)[][] {
  return board.map((row) => row.map((piece) => (piece ? { ...piece } : null)))
}

// Check if a position is within the board boundaries
export function isValidPosition(position: Position): boolean {
  return position.row >= 0 && position.row < 8 && position.col >= 0 && position.col < 8
}

// Update the makeMove function to handle en passant captures
export function makeMove(
  board: (ChessPiece | null)[][],
  from: Position,
  to: Position,
  lastMove: { from: Position; to: Position; piece: ChessPiece } | null = null,
): (ChessPiece | null)[][] {
  const newBoard = cloneBoard(board)
  const piece = newBoard[from.row][from.col]

  if (!piece) return newBoard

  // Update hasMoved flag for kings and rooks (for castling)
  if (piece.type === PieceType.King || piece.type === PieceType.Rook) {
    piece.hasMoved = true
  }

  // Handle castling
  if (piece.type === PieceType.King && Math.abs(to.col - from.col) === 2) {
    const isKingSide = to.col > from.col
    const rookCol = isKingSide ? 7 : 0
    const newRookCol = isKingSide ? 5 : 3

    // Move the rook
    newBoard[from.row][newRookCol] = newBoard[from.row][rookCol]
    newBoard[from.row][rookCol] = null
  }

  // Handle en passant capture
  if (piece.type === PieceType.Pawn && from.col !== to.col && newBoard[to.row][to.col] === null) {
    // This is a diagonal pawn move to an empty square - must be en passant
    newBoard[from.row][to.col] = null // Capture the pawn that moved two squares
  }

  // Handle pawn promotion (automatically to queen for simplicity)
  if (piece.type === PieceType.Pawn && (to.row === 0 || to.row === 7)) {
    piece.type = PieceType.Queen
  }

  // Make the move
  newBoard[to.row][to.col] = piece
  newBoard[from.row][from.col] = null

  return newBoard
}

// Update the isValidMove function to accept lastMove
export function isValidMove(
  board: (ChessPiece | null)[][],
  from: Position,
  to: Position,
  currentPlayer: Color,
  lastMove: { from: Position; to: Position; piece: ChessPiece } | null = null,
): boolean {
  const piece = board[from.row][from.col]

  // Basic checks
  if (!piece) return false
  if (piece.color !== currentPlayer) return false
  if (from.row === to.row && from.col === to.col) return false

  const validMoves = getValidMoves(board, from, currentPlayer, lastMove)
  return validMoves.some((move) => move.row === to.row && move.col === to.col)
}

// Update the getValidMoves function to pass lastMove to getPawnMoves
export function getValidMoves(
  board: (ChessPiece | null)[][],
  position: Position,
  currentPlayer: Color,
  lastMove: { from: Position; to: Position; piece: ChessPiece } | null = null,
): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.color !== currentPlayer) return []

  let moves: Position[] = []

  switch (piece.type) {
    case PieceType.Pawn:
      moves = getPawnMoves(board, position, lastMove)
      break
    case PieceType.Knight:
      moves = getKnightMoves(board, position)
      break
    case PieceType.Bishop:
      moves = getBishopMoves(board, position)
      break
    case PieceType.Rook:
      moves = getRookMoves(board, position)
      break
    case PieceType.Queen:
      moves = getQueenMoves(board, position)
      break
    case PieceType.King:
      moves = getKingMoves(board, position)
      break
  }

  // Filter out moves that would put the king in check
  return moves.filter((move) => {
    const newBoard = makeMove(cloneBoard(board), position, move, lastMove)
    return !isKingInCheck(newBoard, currentPlayer)
  })
}

// Find the king position for a given color
function findKingPosition(board: (ChessPiece | null)[][], color: Color): Position | null {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col]
      if (piece?.type === PieceType.King && piece.color === color) {
        return { row, col }
      }
    }
  }
  return null
}

// Check if the king is in check
export function isKingInCheck(board: (ChessPiece | null)[][], color: Color): boolean {
  // Find the king
  const kingPosition = findKingPosition(board, color)
  if (!kingPosition) return false // Should never happen in a valid game

  // Check if any opponent piece can capture the king
  const oppositeColor = color === Color.White ? Color.Black : Color.White
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col]
      if (piece && piece.color === oppositeColor) {
        const moves = getPieceMoves(board, { row, col }, false)
        if (moves.some((move) => move.row === kingPosition.row && move.col === kingPosition.col)) {
          return true
        }
      }
    }
  }

  return false
}

// Get all pieces that are attacking the king
function getCheckingPieces(board: (ChessPiece | null)[][], color: Color): Position[] {
  const kingPosition = findKingPosition(board, color)
  if (!kingPosition) return []

  const checkingPieces: Position[] = []
  const oppositeColor = color === Color.White ? Color.Black : Color.White

  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col]
      if (piece && piece.color === oppositeColor) {
        const moves = getPieceMoves(board, { row, col }, false)
        if (moves.some((move) => move.row === kingPosition.row && move.col === kingPosition.col)) {
          checkingPieces.push({ row, col })
        }
      }
    }
  }

  return checkingPieces
}

// Get all squares between two positions (for blocking checks)
function getSquaresBetween(from: Position, to: Position): Position[] {
  const squares: Position[] = []

  // Check if the positions are on the same row, column, or diagonal
  const rowDiff = to.row - from.row
  const colDiff = to.col - from.col

  // If not on the same line, return empty array
  if (rowDiff !== 0 && colDiff !== 0 && Math.abs(rowDiff) !== Math.abs(colDiff)) {
    return squares
  }

  const rowStep = rowDiff === 0 ? 0 : rowDiff > 0 ? 1 : -1
  const colStep = colDiff === 0 ? 0 : colDiff > 0 ? 1 : -1

  let row = from.row + rowStep
  let col = from.col + colStep

  while (row !== to.row || col !== to.col) {
    squares.push({ row, col })
    row += rowStep
    col += colStep
  }

  return squares
}

// Update the getPieceMoves function to pass lastMove to getPawnMoves
function getPieceMoves(
  board: (ChessPiece | null)[][],
  position: Position,
  checkCastling = true,
  lastMove: { from: Position; to: Position; piece: ChessPiece } | null = null,
): Position[] {
  const piece = board[position.row][position.col]
  if (!piece) return []

  switch (piece.type) {
    case PieceType.Pawn:
      return getPawnMoves(board, position, lastMove)
    case PieceType.Knight:
      return getKnightMoves(board, position)
    case PieceType.Bishop:
      return getBishopMoves(board, position)
    case PieceType.Rook:
      return getRookMoves(board, position)
    case PieceType.Queen:
      return getQueenMoves(board, position)
    case PieceType.King:
      return getKingMoves(board, position, checkCastling)
    default:
      return []
  }
}

// Update the getPawnMoves function to include en passant
function getPawnMoves(
  board: (ChessPiece | null)[][],
  position: Position,
  lastMove: { from: Position; to: Position; piece: ChessPiece } | null = null,
): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.Pawn) return []

  const moves: Position[] = []
  const direction = piece.color === Color.White ? -1 : 1
  const startRow = piece.color === Color.White ? 6 : 1

  // Move forward one square
  const oneForward = { row: position.row + direction, col: position.col }
  if (isValidPosition(oneForward) && board[oneForward.row][oneForward.col] === null) {
    moves.push(oneForward)

    // Move forward two squares from starting position
    if (position.row === startRow) {
      const twoForward = { row: position.row + 2 * direction, col: position.col }
      if (isValidPosition(twoForward) && board[twoForward.row][twoForward.col] === null) {
        moves.push(twoForward)
      }
    }
  }

  // Capture diagonally
  const captureMoves = [
    { row: position.row + direction, col: position.col - 1 },
    { row: position.row + direction, col: position.col + 1 },
  ]

  for (const move of captureMoves) {
    if (isValidPosition(move)) {
      const targetPiece = board[move.row][move.col]
      if (targetPiece && targetPiece.color !== piece.color) {
        moves.push(move)
      }
    }
  }

  // En passant capture
  if (lastMove && lastMove.piece.type === PieceType.Pawn) {
    const lastMoveDistance = Math.abs(lastMove.to.row - lastMove.from.row)

    // Check if the last move was a pawn moving two squares
    if (lastMoveDistance === 2) {
      // Check if our pawn is adjacent to the pawn that just moved
      if (
        position.row === lastMove.to.row &&
        Math.abs(position.col - lastMove.to.col) === 1 &&
        lastMove.piece.color !== piece.color
      ) {
        // Add the en passant capture move
        moves.push({
          row: position.row + direction,
          col: lastMove.to.col,
        })
      }
    }
  }

  return moves
}

// Get all valid moves for a knight
function getKnightMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.Knight) return []

  const moves: Position[] = []
  const knightMoves = [
    { row: position.row - 2, col: position.col - 1 },
    { row: position.row - 2, col: position.col + 1 },
    { row: position.row - 1, col: position.col - 2 },
    { row: position.row - 1, col: position.col + 2 },
    { row: position.row + 1, col: position.col - 2 },
    { row: position.row + 1, col: position.col + 2 },
    { row: position.row + 2, col: position.col - 1 },
    { row: position.row + 2, col: position.col + 1 },
  ]

  for (const move of knightMoves) {
    if (isValidPosition(move)) {
      const targetPiece = board[move.row][move.col]
      if (!targetPiece || targetPiece.color !== piece.color) {
        moves.push(move)
      }
    }
  }

  return moves
}

// Get all valid moves for a bishop
function getBishopMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.Bishop) return []

  return getDiagonalMoves(board, position)
}

// Get all valid moves for a rook
function getRookMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.Rook) return []

  return getStraightMoves(board, position)
}

// Get all valid moves for a queen
function getQueenMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.Queen) return []

  return [...getStraightMoves(board, position), ...getDiagonalMoves(board, position)]
}

// Get all valid moves for a king
function getKingMoves(board: (ChessPiece | null)[][], position: Position, checkCastling = true): Position[] {
  const piece = board[position.row][position.col]
  if (!piece || piece.type !== PieceType.King) return []

  const moves: Position[] = []
  const kingMoves = [
    { row: position.row - 1, col: position.col - 1 },
    { row: position.row - 1, col: position.col },
    { row: position.row - 1, col: position.col + 1 },
    { row: position.row, col: position.col - 1 },
    { row: position.row, col: position.col + 1 },
    { row: position.row + 1, col: position.col - 1 },
    { row: position.row + 1, col: position.col },
    { row: position.row + 1, col: position.col + 1 },
  ]

  for (const move of kingMoves) {
    if (isValidPosition(move)) {
      const targetPiece = board[move.row][move.col]
      if (!targetPiece || targetPiece.color !== piece.color) {
        moves.push(move)
      }
    }
  }

  // Castling
  if (checkCastling && !piece.hasMoved && !isKingInCheck(board, piece.color)) {
    const row = position.row

    // Kingside castling
    if (board[row][7]?.type === PieceType.Rook && !board[row][7]?.hasMoved && !board[row][5] && !board[row][6]) {
      // Check if the king would pass through check
      const tempBoard1 = cloneBoard(board)
      tempBoard1[row][5] = piece
      tempBoard1[row][4] = null

      if (!isKingInCheck(tempBoard1, piece.color)) {
        moves.push({ row, col: 6 })
      }
    }

    // Queenside castling
    if (
      board[row][0]?.type === PieceType.Rook &&
      !board[row][0]?.hasMoved &&
      !board[row][1] &&
      !board[row][2] &&
      !board[row][3]
    ) {
      // Check if the king would pass through check
      const tempBoard1 = cloneBoard(board)
      tempBoard1[row][3] = piece
      tempBoard1[row][4] = null

      if (!isKingInCheck(tempBoard1, piece.color)) {
        moves.push({ row, col: 2 })
      }
    }
  }

  return moves
}

// Get all diagonal moves (for bishop and queen)
function getDiagonalMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece) return []

  const moves: Position[] = []

  // Check all four diagonal directions
  const directions = [
    { rowDir: -1, colDir: -1 }, // top-left
    { rowDir: -1, colDir: 1 }, // top-right
    { rowDir: 1, colDir: -1 }, // bottom-left
    { rowDir: 1, colDir: 1 }, // bottom-right
  ]

  for (const dir of directions) {
    let row = position.row + dir.rowDir
    let col = position.col + dir.colDir

    while (isValidPosition({ row, col })) {
      const targetPiece = board[row][col]

      if (!targetPiece) {
        // Empty square, can move here
        moves.push({ row, col })
      } else if (targetPiece.color !== piece.color) {
        // Opponent's piece, can capture and then stop
        moves.push({ row, col })
        break
      } else {
        // Own piece, can't move here or beyond
        break
      }

      row += dir.rowDir
      col += dir.colDir
    }
  }

  return moves
}

// Get all straight moves (for rook and queen)
function getStraightMoves(board: (ChessPiece | null)[][], position: Position): Position[] {
  const piece = board[position.row][position.col]
  if (!piece) return []

  const moves: Position[] = []

  // Check all four straight directions
  const directions = [
    { rowDir: -1, colDir: 0 }, // up
    { rowDir: 1, colDir: 0 }, // down
    { rowDir: 0, colDir: -1 }, // left
    { rowDir: 0, colDir: 1 }, // right
  ]

  for (const dir of directions) {
    let row = position.row + dir.rowDir
    let col = position.col + dir.colDir

    while (isValidPosition({ row, col })) {
      const targetPiece = board[row][col]

      if (!targetPiece) {
        // Empty square, can move here
        moves.push({ row, col })
      } else if (targetPiece.color !== piece.color) {
        // Opponent's piece, can capture and then stop
        moves.push({ row, col })
        break
      } else {
        // Own piece, can't move here or beyond
        break
      }

      row += dir.rowDir
      col += dir.colDir
    }
  }

  return moves
}

// Check if the current player is in check
export function isCheck(board: (ChessPiece | null)[][], currentPlayer: Color): boolean {
  return isKingInCheck(board, currentPlayer)
}

// Check if the current player is in checkmate
export function isCheckmate(board: (ChessPiece | null)[][], currentPlayer: Color): boolean {
  // If not in check, can't be checkmate
  if (!isKingInCheck(board, currentPlayer)) return false

  // Check if any move can get out of check
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const piece = board[row][col]
      if (piece && piece.color === currentPlayer) {
        const moves = getValidMoves(board, { row, col }, currentPlayer)
        if (moves.length > 0) {
          return false // Found at least one legal move
        }
      }
    }
  }

  // No legal moves and in check = checkmate
  return true
}
```

Then, we create a helpful utility for enumerating all the types associated with the game of chess.

```tsx file="lib/chess-types.ts"
export enum PieceType {
  King = "king",
  Queen = "queen",
  Rook = "rook",
  Bishop = "bishop",
  Knight = "knight",
  Pawn = "pawn",
}

export enum Color {
  White = "white",
  Black = "black",
}

export interface Position {
  row: number
  col: number
}

export interface ChessPiece {
  type: PieceType
  color: Color
  hasMoved?: boolean
}

export const initialBoardState: (ChessPiece | null)[][] = [
  [
    { type: PieceType.Rook, color: Color.Black },
    { type: PieceType.Knight, color: Color.Black },
    { type: PieceType.Bishop, color: Color.Black },
    { type: PieceType.Queen, color: Color.Black },
    { type: PieceType.King, color: Color.Black },
    { type: PieceType.Bishop, color: Color.Black },
    { type: PieceType.Knight, color: Color.Black },
    { type: PieceType.Rook, color: Color.Black },
  ],
  Array(8)
    .fill(null)
    .map(() => ({ type: PieceType.Pawn, color: Color.Black })),
  Array(8).fill(null),
  Array(8).fill(null),
  Array(8).fill(null),
  Array(8).fill(null),
  Array(8)
    .fill(null)
    .map(() => ({ type: PieceType.Pawn, color: Color.White })),
  [
    { type: PieceType.Rook, color: Color.White },
    { type: PieceType.Knight, color: Color.White },
    { type: PieceType.Bishop, color: Color.White },
    { type: PieceType.Queen, color: Color.White },
    { type: PieceType.King, color: Color.White },
    { type: PieceType.Bishop, color: Color.White },
    { type: PieceType.Knight, color: Color.White },
    { type: PieceType.Rook, color: Color.White },
  ],
]
```

