Let's create the layout for the cube, the controls, and the game state.

```tsx file="app/layout.tsx"
import type { Metadata } from 'next'
import './globals.css'

export const metadata: Metadata = {
  title: 'v0 App',
  description: 'Created with v0',
  generator: 'v0.dev',
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

Then, we will create a one page application to contain all the components.

```tsx file="app/page.tsx"
import RubiksCubeGame from "@/components/rubiks-cube-game"

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center">
      <RubiksCubeGame />
    </main>
  )
}
```

We must also provide the theme and styling to all the components.

```tsx file="components/theme-provider.tsx"
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
```

Next, we'll make a set of 11 buttons that enable twists and turns of all of the faces of the cube.

```tsx file="components/rotate-controls.tsx"
"use client"

import { Button } from "@/components/ui/button"
import { ArrowUp, ArrowDown, ArrowLeft, ArrowRight, RotateCcw, RotateCw } from "lucide-react"

interface RotateControlsProps {
  onRotate: (face: string, direction: string) => void
}

export function RotateControls({ onRotate }: RotateControlsProps) {
  return (
    <div className="bg-background/80 p-4 rounded-lg flex flex-col items-center gap-2">
      <div className="text-sm font-medium mb-2">Rotate Faces</div>

      <div className="grid grid-cols-3 gap-2">
        <Button variant="outline" size="icon" onClick={() => onRotate("left", "up")} className="h-10 w-10">
          <ArrowUp className="h-5 w-5" />
          <span className="sr-only">Rotate left face up</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("front", "up")} className="h-10 w-10">
          <ArrowUp className="h-5 w-5" />
          <span className="sr-only">Rotate front face up</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("right", "up")} className="h-10 w-10">
          <ArrowUp className="h-5 w-5" />
          <span className="sr-only">Rotate right face up</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("left", "left")} className="h-10 w-10">
          <ArrowLeft className="h-5 w-5" />
          <span className="sr-only">Rotate left face left</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("top", "clockwise")} className="h-10 w-10">
          <RotateCw className="h-5 w-5" />
          <span className="sr-only">Rotate top face clockwise</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("right", "right")} className="h-10 w-10">
          <ArrowRight className="h-5 w-5" />
          <span className="sr-only">Rotate right face right</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("left", "down")} className="h-10 w-10">
          <ArrowDown className="h-5 w-5" />
          <span className="sr-only">Rotate left face down</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("front", "down")} className="h-10 w-10">
          <ArrowDown className="h-5 w-5" />
          <span className="sr-only">Rotate front face down</span>
        </Button>

        <Button variant="outline" size="icon" onClick={() => onRotate("right", "down")} className="h-10 w-10">
          <ArrowDown className="h-5 w-5" />
          <span className="sr-only">Rotate right face down</span>
        </Button>
      </div>

      <div className="grid grid-cols-2 gap-2 mt-2">
        <Button variant="outline" size="sm" onClick={() => onRotate("bottom", "counterclockwise")} className="h-8">
          <RotateCcw className="h-4 w-4 mr-1" />
          <span>Bottom</span>
        </Button>

        <Button variant="outline" size="sm" onClick={() => onRotate("back", "clockwise")} className="h-8">
          <RotateCw className="h-4 w-4 mr-1" />
          <span>Back</span>
        </Button>
      </div>
    </div>
  )
}
```

Then, we need to create the colorful cube itself.

```tsx file="components/rubiks-cube.tsx"
"use client"

import React from "react"
import { useRef, useEffect } from "react"
import { useFrame } from "@react-three/fiber"
import type { Group, Mesh } from "three"

interface CubieProps {
  position: [number, number, number]
  colors: string[]
}

interface RubiksCubeProps {
  isSolved: boolean
  ref?: React.RefObject<Group>
}

// Individual cubie (small cube) component
function Cubie({ position, colors }: CubieProps) {
  const meshRef = useRef<Mesh>(null)

  // Map colors to faces: [right, left, top, bottom, front, back]
  const colorMap = {
    red: "#e53935",
    orange: "#ff9800",
    yellow: "#fdd835",
    green: "#43a047",
    blue: "#1e88e5",
    white: "#f5f5f5",
    black: "#212121",
  }

  // Store the original position and colors for solved state detection
  useEffect(() => {
    if (meshRef.current) {
      meshRef.current.userData.originalPosition = [...position]
      meshRef.current.userData.originalColors = [...colors]

      // Set the name to the position for easy reset
      meshRef.current.name = `${position[0]}-${position[1]}-${position[2]}`
    }
  }, [])

  return (
    <mesh ref={meshRef} position={position} castShadow name={`${position[0]}-${position[1]}-${position[2]}`}>
      <boxGeometry args={[0.95, 0.95, 0.95]} />
      <meshStandardMaterial
        attach="material-0"
        color={colors[0] ? colorMap[colors[0] as keyof typeof colorMap] : colorMap.black}
      />
      <meshStandardMaterial
        attach="material-1"
        color={colors[1] ? colorMap[colors[1] as keyof typeof colorMap] : colorMap.black}
      />
      <meshStandardMaterial
        attach="material-2"
        color={colors[2] ? colorMap[colors[2] as keyof typeof colorMap] : colorMap.black}
      />
      <meshStandardMaterial
        attach="material-3"
        color={colors[3] ? colorMap[colors[3] as keyof typeof colorMap] : colorMap.black}
      />
      <meshStandardMaterial
        attach="material-4"
        color={colors[4] ? colorMap[colors[4] as keyof typeof colorMap] : colorMap.black}
      />
      <meshStandardMaterial
        attach="material-5"
        color={colors[5] ? colorMap[colors[5] as keyof typeof colorMap] : colorMap.black}
      />
    </mesh>
  )
}

// Main Rubik's Cube component
export const RubiksCube = React.forwardRef<Group, RubiksCubeProps>(({ isSolved }, ref) => {
  const localRef = useRef<Group>(null)
  const groupRef = ref || localRef

  useFrame((state, delta) => {
    if (groupRef.current) {
      // Gentle rotation when idle, but only if not being actively rotated
      const isRotating = groupRef.current.children.some((child) => child.userData.rotating)

      if (!isRotating) {
        // Gentle rotation when idle
        groupRef.current.rotation.y += delta * 0.1

        // Celebration rotation when solved
        if (isSolved) {
          groupRef.current.rotation.x += delta * 0.2
          groupRef.current.rotation.z += delta * 0.1
        }
      }
    }
  })

  // Create a 3x3x3 cube
  const createCube = () => {
    const cubies = []
    const positions = [-1, 0, 1]

    for (const x of positions) {
      for (const y of positions) {
        for (const z of positions) {
          // Skip the inner cube (not visible)
          if (x === 0 && y === 0 && z === 0) continue

          // Determine colors for each face
          const colors = [
            x === 1 ? "red" : "", // right
            x === -1 ? "orange" : "", // left
            y === 1 ? "yellow" : "", // top
            y === -1 ? "white" : "", // bottom
            z === 1 ? "green" : "", // front
            z === -1 ? "blue" : "", // back
          ]

          cubies.push(<Cubie key={`${x}-${y}-${z}`} position={[x, y, z]} colors={colors} />)
        }
      }
    }

    return cubies
  }

  return <group ref={groupRef}>{createCube()}</group>
})
```

Then, we create the game component itself, with logic for handling all of the state transitions.

```tsx file="components/rubiks-cube-game.tsx"
"use client"

import { useState, useEffect, useRef } from "react"
import { Canvas } from "@react-three/fiber"
import { OrbitControls, Environment } from "@react-three/drei"
import { Button } from "@/components/ui/button"
import { RubiksCube } from "./rubiks-cube"
import { RotateControls } from "./rotate-controls"
import * as THREE from "three"

export default function RubiksCubeGame() {
  const [cubeState, setCubeState] = useState<string[][][]>([])
  const [isSolved, setIsSolved] = useState(false)
  const [moves, setMoves] = useState(0)
  const [gameStarted, setGameStarted] = useState(false)
  const [key, setKey] = useState(0) // Key to force re-render of the cube
  const groupRef = useRef<THREE.Group>(null)

  // Initialize cube state
  useEffect(() => {
    if (!gameStarted) return

    // Create a solved cube state (3x3x3)
    const colors = ["red", "orange", "yellow", "green", "blue", "white"]
    const newCubeState = colors.map((color) =>
      Array(3)
        .fill(null)
        .map(() => Array(3).fill(color)),
    )

    setCubeState(newCubeState)
    setIsSolved(true)
    setMoves(0)
  }, [gameStarted, key])

  // Scramble the cube
  const scrambleCube = () => {
    if (!groupRef.current) return

    // Perform a series of random rotations
    const faces = ["front", "back", "left", "right", "top", "bottom"]
    const directions = ["clockwise", "counterclockwise"]

    // Apply 20 random rotations
    const scrambleCount = 20
    let scrambleIndex = 0

    const performScramble = () => {
      if (scrambleIndex >= scrambleCount) {
        setIsSolved(false)
        setMoves(0)
        return
      }

      const randomFace = faces[Math.floor(Math.random() * faces.length)]
      const randomDirection = directions[Math.floor(Math.random() * directions.length)]

      rotateFace(randomFace, randomDirection)

      // Schedule the next rotation
      setTimeout(() => {
        scrambleIndex++
        performScramble()
      }, 100)
    }

    performScramble()
  }

  // Reset the cube to solved state
  const resetCube = () => {
    // Completely reset the cube by forcing a re-render with a new key
    setKey((prevKey) => prevKey + 1)

    // Reset the internal state
    const colors = ["red", "orange", "yellow", "green", "blue", "white"]
    const newCubeState = colors.map((color) =>
      Array(3)
        .fill(null)
        .map(() => Array(3).fill(color)),
    )

    setCubeState(newCubeState)
    setIsSolved(true)
    setMoves(0)
  }

  // Handle cube face rotation
  const rotateFace = (face: string, direction: string) => {
    if (!cubeState.length) return

    // Create a deep copy of the current cube state
    const newCubeState = JSON.parse(JSON.stringify(cubeState))

    // Update the cube state based on the rotation
    // This is a simplified implementation that will visually rotate the cube
    if (groupRef.current) {
      let axis = [0, 0, 0]
      const angle =
        direction.includes("clockwise") || direction === "right" || direction === "up" ? Math.PI / 2 : -Math.PI / 2

      switch (face) {
        case "front":
          axis = [0, 0, 1]
          break
        case "back":
          axis = [0, 0, -1]
          break
        case "left":
          axis = [-1, 0, 0]
          break
        case "right":
          axis = [1, 0, 0]
          break
        case "top":
          axis = [0, 1, 0]
          break
        case "bottom":
          axis = [0, -1, 0]
          break
      }

      // Trigger the rotation animation
      rotateLayer(face, axis, angle)
    }

    setCubeState(newCubeState)
    setMoves((prev) => prev + 1)

    // Check if cube is solved after rotation
    // In a real implementation, this would check the actual state
    checkIfSolved()
  }

  const rotateLayer = (face: string, axis: number[], angle: number) => {
    if (!groupRef.current) return

    // Find the cubies that belong to the face being rotated
    const faceGroup = new THREE.Group()
    const threshold = 0.5 // Distance threshold to determine if a cubie is on the face

    groupRef.current.children.forEach((child) => {
      const position = child.position.clone()

      // Check if the cubie is on the specified face
      let isOnFace = false
      if (face === "front" && Math.abs(position.z - 1) < threshold) isOnFace = true
      if (face === "back" && Math.abs(position.z + 1) < threshold) isOnFace = true
      if (face === "left" && Math.abs(position.x + 1) < threshold) isOnFace = true
      if (face === "right" && Math.abs(position.x - 1) < threshold) isOnFace = true
      if (face === "top" && Math.abs(position.y - 1) < threshold) isOnFace = true
      if (face === "bottom" && Math.abs(position.y + 1) < threshold) isOnFace = true

      if (isOnFace) {
        // Add this cubie to the rotation group
        faceGroup.add(child.clone())

        // Store the original position
        child.userData.originalPosition = position.clone()
        child.userData.rotating = true
      }
    })

    // Animate the rotation
    const axisVector = new THREE.Vector3(axis[0], axis[1], axis[2])
    const rotationMatrix = new THREE.Matrix4().makeRotationAxis(axisVector.normalize(), angle)

    // Apply rotation to each cubie in the face
    groupRef.current.children.forEach((child) => {
      if (child.userData.rotating) {
        const newPosition = child.userData.originalPosition.clone().applyMatrix4(rotationMatrix)
        child.position.copy(newPosition)
        child.rotation.setFromRotationMatrix(
          new THREE.Matrix4()
            .makeRotationAxis(axisVector.normalize(), angle)
            .multiply(new THREE.Matrix4().makeRotationFromEuler(child.rotation)),
        )
        delete child.userData.rotating
      }
    })
  }

  const checkIfSolved = () => {
    if (!groupRef.current) return

    // Get all cubies
    const cubies = groupRef.current.children

    // Check if each face has the same color
    const faces = [
      { name: "right", axis: "x", value: 1 },
      { name: "left", axis: "x", value: -1 },
      { name: "top", axis: "y", value: 1 },
      { name: "bottom", axis: "y", value: -1 },
      { name: "front", axis: "z", value: 1 },
      { name: "back", axis: "z", value: -1 },
    ]

    let allFacesSolved = true

    // For each face, check if all visible cubies have the same orientation
    faces.forEach((face) => {
      const faceCubies = []

      // Find cubies on this face
      cubies.forEach((cubie) => {
        const position = cubie.position
        const threshold = 0.5

        if (face.axis === "x" && Math.abs(position.x - face.value) < threshold) {
          faceCubies.push(cubie)
        } else if (face.axis === "y" && Math.abs(position.y - face.value) < threshold) {
          faceCubies.push(cubie)
        } else if (face.axis === "z" && Math.abs(position.z - face.value) < threshold) {
          faceCubies.push(cubie)
        }
      })

      // Check if all cubies on this face have the same orientation
      if (faceCubies.length > 0) {
        const referenceRotation = faceCubies[0].rotation.clone()

        for (let i = 1; i < faceCubies.length; i++) {
          const rotation = faceCubies[i].rotation

          // Compare rotations (with some tolerance for floating point errors)
          const tolerance = 0.1
          if (
            Math.abs(rotation.x - referenceRotation.x) > tolerance ||
            Math.abs(rotation.y - referenceRotation.y) > tolerance ||
            Math.abs(rotation.z - referenceRotation.z) > tolerance
          ) {
            allFacesSolved = false
            break
          }
        }
      }
    })

    setIsSolved(allFacesSolved)
  }

  return (
    <div className="w-full h-screen flex flex-col">
      {!gameStarted ? (
        <div className="absolute inset-0 flex items-center justify-center z-10">
          <div className="bg-background p-8 rounded-lg shadow-lg text-center">
            <h1 className="text-3xl font-bold mb-4">Rubik's Cube Game</h1>
            <p className="mb-6">Rotate the cube and solve the puzzle!</p>
            <Button onClick={() => setGameStarted(true)} className="px-6 py-3">
              Start Game
            </Button>
          </div>
        </div>
      ) : (
        <>
          <div className="absolute top-4 left-4 z-10 bg-background/80 p-4 rounded-lg">
            <div className="text-lg font-bold mb-2">Moves: {moves}</div>
            {isSolved && moves > 0 && <div className="text-green-500 font-bold mb-2">Solved! 🎉</div>}
            <div className="flex gap-2">
              <Button onClick={scrambleCube} variant="outline">
                Scramble
              </Button>
              <Button onClick={resetCube} variant="outline">
                Reset
              </Button>
            </div>
          </div>

          <Canvas camera={{ position: [0, 0, 8], fov: 50 }} key={key}>
            <ambientLight intensity={0.5} />
            <pointLight position={[10, 10, 10]} intensity={1} />
            <RubiksCube isSolved={isSolved} ref={groupRef} />
            <OrbitControls enablePan={false} minDistance={5} maxDistance={15} />
            <Environment preset="city" />
          </Canvas>

          <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-10">
            <RotateControls onRotate={rotateFace} />
          </div>
        </>
      )}
    </div>
  )
}
```

We also need a toast indicator for alerts to the user.

```tsx file="hooks/use-toast.ts"
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
```

Then, we'll create a utility for detecting mobile devices.

```tsx file="hooks/use-mobile.tsx"
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
```

We will also merge in Tailwind styling into JS environment.

```tsx file="lib/utils.ts"
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

